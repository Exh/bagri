<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:hz="http://www.hazelcast.com/schema/spring"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd
		http://www.hazelcast.com/schema/spring http://www.hazelcast.com/schema/spring/hazelcast-spring-3.2.xsd">

	<!--import resource="classpath:spring/xml-context.xml" /-->
 
	<!-- Beans Declaration -->
	<context:property-placeholder ignore-unresolvable="true" location="classpath:/${xdm.config.properties.file}" />
	<context:annotation-config />
	<context:mbean-export default-domain="com.bagri.xdm"/>
 
	<hz:hazelcast id="hzInstance">
		<hz:config>
			<hz:instance-name>${xdm.schema.name}</hz:instance-name>
			<hz:group name="${xdm.schema.name}" password="${xdm.schema.password}"/>
			<hz:properties>
				<hz:property name="hazelcast.jmx">true</hz:property>
				<hz:property name="hazelcast.jmx.detailed">true</hz:property>
				<hz:property name="hazelcast.logging.type">slf4j</hz:property>
			</hz:properties>
			<hz:network port="${xdm.schema.ports.start}" port-auto-increment="true">
				<hz:outbound-ports>
					<hz:ports>${xdm.schema.ports}</hz:ports> 
				</hz:outbound-ports>
				<hz:join>
					<hz:multicast enabled="false" />
					<hz:tcp-ip enabled="true" connection-timeout-seconds="10">
						<hz:members>${xdm.schema.members}</hz:members>
					</hz:tcp-ip>
				</hz:join>
			</hz:network>
			<hz:executor-service name="xdm-exec-pool" pool-size="${xdm.schema.thread.pool}" />
			
			<hz:map name="dict-namespace">
				<hz:near-cache time-to-live-seconds="0" max-idle-seconds="60" eviction-policy="LRU" 
					max-size="0" invalidate-on-change="true"/>
			</hz:map>
			<hz:map name="dict-path">
				<hz:near-cache time-to-live-seconds="0" max-idle-seconds="60" eviction-policy="LRU" 
					max-size="0" invalidate-on-change="true"/>
				<hz:indexes>
					<hz:index attribute="typeId"/>
					<hz:index attribute="path" ordered="true"/>
				</hz:indexes>
			</hz:map>
			<hz:map name="dict-document-type">
				<hz:map-store enabled="true" write-delay-seconds="10" factory-implementation="xdmStoreFactory">
					<hz:properties>
						<hz:property name="xdm.schema.store.type">NONE</hz:property>
					</hz:properties>
				</hz:map-store>
				<hz:near-cache time-to-live-seconds="0" max-idle-seconds="60" eviction-policy="LRU" 
					max-size="0" invalidate-on-change="true"/>
			</hz:map>
			
			<hz:map name="xdm-document">
				<!--hz:map-store enabled="true" write-delay-seconds="10" initial-mode="LAZY" factory-implementation="xdmStoreFactory">
					<hz:properties>
						<hz:property name="xdm.schema.store.type">${xdm.schema.store.type}</hz:property>
					</hz:properties>
				</hz:map-store-->
				<hz:indexes>
					<hz:index attribute="documentId"/>
				</hz:indexes>
			</hz:map>
			<hz:map name="xdm-element">
				<!-- can't persist it in MongoDB right away; got an exception: 
					java.lang.IllegalArgumentException: can't serialize class com.bagri.xdm.access.hazelcast.data.DataDocumentKey -->
				<!--hz:map-store enabled="true" write-delay-seconds="10" initial-mode="LAZY" factory-implementation="xdmStoreFactory">
					<hz:properties>
						<hz:property name="xdm.schema.store.type">${xdm.schema.store.type}</hz:property>
					</hz:properties>
				</hz:map-store-->
				<hz:indexes>
					<hz:index attribute="documentId"/>
					<hz:index attribute="path" ordered="true"/>
					<hz:index attribute="value"/>
				</hz:indexes>
			</hz:map>
			
			<hz:serialization>
				<hz:data-serializable-factories>
					<hz:data-serializable-factory factory-id="2" class-name="com.bagri.xdm.process.hazelcast.pof.XDMDataSerializationFactory"/>
				</hz:data-serializable-factories>
				<hz:portable-factories>
					<hz:portable-factory factory-id="1" class-name="com.bagri.xdm.process.hazelcast.pof.XDMPortableFactory"/>
				</hz:portable-factories>
				<hz:serializers>
					<!--hz:global-serializer class-name="com.hazelcast.nio.serialization.PortableSerializer"/-->
					<hz:serializer type-class="com.bagri.xdm.domain.XDMElement" class-name="com.bagri.xdm.access.hazelcast.pof.XDMElementSerializer"/>
					<hz:serializer type-class="com.bagri.xdm.domain.XDMPath" class-name="com.bagri.xdm.access.hazelcast.pof.XDMPathSerializer"/>
					<hz:serializer type-class="com.bagri.xdm.domain.XDMDocument" class-name="com.bagri.xdm.access.hazelcast.pof.XDMDocumentSerializer"/>
					<hz:serializer type-class="com.bagri.xdm.domain.XDMDocumentType" class-name="com.bagri.xdm.access.hazelcast.pof.XDMDocumentTypeSerializer"/>
					<hz:serializer type-class="com.bagri.xdm.domain.XDMNamespace" class-name="com.bagri.xdm.access.hazelcast.pof.XDMNamespaceSerializer"/>
					<hz:serializer type-class="com.bagri.xdm.access.hazelcast.impl.HazelcastXQCursor" class-name="com.bagri.xdm.access.hazelcast.pof.XDMCursorSerializer"/>
					<hz:serializer type-class="com.bagri.xqj.BagriXQItem" class-name="com.bagri.xdm.access.hazelcast.pof.XQItemSerializer"/>
					<hz:serializer type-class="com.bagri.xqj.BagriXQItemType" class-name="com.bagri.xdm.access.hazelcast.pof.XQItemTypeSerializer"/>
				</hz:serializers>
			</hz:serialization>

			<!--hz:security enabled="true">
				<hz:client-login-modules>
					<hz:login-module class-name="com.bagri.xdm.cache.hazelcast.security.BagriLoginModule" usage="REQUIRED">
						<hz:properties>
							<hz:property name="property3">value3</hz:property>
						</hz:properties>
					</hz:login-module>
				</hz:client-login-modules>
			</hz:security-->
		</hz:config>
	</hz:hazelcast>

	<hz:map id="xdm-document" name="xdm-document" instance-ref="hzInstance" />
	<hz:map id="xdm-element" name="xdm-element" instance-ref="hzInstance" />
	<hz:map id="dict-document-type" name="dict-document-type" instance-ref="hzInstance" />
	<hz:map id="dict-path" name="dict-path" instance-ref="hzInstance" />
	<hz:map id="dict-namespace" name="dict-namespace" instance-ref="hzInstance" />

	<hz:idGenerator id="xdm.document" name="xdm.document" instance-ref="hzInstance"/>
	<hz:idGenerator id="xdm.element" name="xdm.element" instance-ref="hzInstance"/>
	<hz:idGenerator id="xdm.path" name="xdm.path" instance-ref="hzInstance"/>
	<hz:idGenerator id="xdm.namespace" name="xdm.namespace" instance-ref="hzInstance"/>
	<hz:idGenerator id="xdm.doctype" name="xdm.doctype" instance-ref="hzInstance"/>
	
	<hz:executorService id="xdm-exec-pool" name="xdm-exec-pool" instance-ref="hzInstance"/>
	
	<bean id="xdmDictionary" class="com.bagri.xdm.access.hazelcast.impl.HazelcastSchemaDictionary">
		<constructor-arg ref="hzInstance" />
	</bean>

	<bean id="xdmFactory" class="com.bagri.xdm.access.hazelcast.impl.HazelcastXDMFactory"/>

	<bean id="xdmStoreFactory" class="com.bagri.xdm.cache.hazelcast.store.XDMMapStoreFactory"/>

	<bean id="eltGen" class="com.bagri.xdm.access.hazelcast.impl.HazelcastIdGenerator">
		<constructor-arg ref="xdm.element" />
	</bean>
	
	<!--bean id="docGen" class="com.bagri.xdm.access.hazelcast.impl.HazelcastIdGenerator">
		<constructor-arg ref="xdm.document" />
	</bean-->

	<bean id="xdmManager" class="com.bagri.xdm.process.hazelcast.HazelcastDocumentServer">
		<property name="elementIdGenerator" ref="eltGen"/>
		<property name="documentIdGenerator" ref="xdm.document"/>
		<property name="hzInstance" ref="hzInstance"/>
		<property name="xdmFactory" ref="xdmFactory"/>
		<property name="xddCache" ref="xdm-document"/>
		<property name="xdmCache" ref="xdm-element"/>
		<property name="schemaDictionary" ref="xdmDictionary"/>
		<property name="XQProcessor" ref="xqProcessor"/>
	</bean>
	
	<bean id="xqFactory" class="com.bagri.xqj.BagriXQDataFactory"/>
	
    <bean id="xqProcessor" class="com.bagri.xquery.saxon.BagriXQProcessor">
    	<!--property name="xdmManager" ref="xdmManager" /-->
    	<property name="XQDataFactory" ref="xqFactory" />
		<property name="properties">
			<props>
				<prop key="xqj.schema.baseUri">${xqj.schema.baseUri}</prop>
				<prop key="xqj.schema.constructionMode">${xqj.schema.constructionMode}</prop>
				<prop key="xqj.schema.defaultCollationUri">${xqj.schema.defaultCollationUri}</prop>
				<prop key="xqj.schema.defaultElementTypeNamespace">${xqj.schema.defaultElementTypeNamespace}</prop>
				<prop key="xqj.schema.defaultFunctionNamespace">${xqj.schema.defaultFunctionNamespace}</prop>
				<prop key="xqj.schema.orderingMode">${xqj.schema.orderingMode}</prop>
				<prop key="xqj.schema.defaultOrderForEmptySequences">${xqj.schema.defaultOrderForEmptySequences}</prop>
				<prop key="xqj.schema.boundarySpacePolicy">${xqj.schema.boundarySpacePolicy}</prop>
				<prop key="xqj.schema.copyNamespacesModePreserve">${xqj.schema.copyNamespacesModePreserve}</prop>
				<prop key="xqj.schema.copyNamespacesModeInherit">${xqj.schema.copyNamespacesModeInherit}</prop>
				<prop key="xqj.schema.bindingMode">${xqj.schema.bindingMode}</prop>
				<prop key="xqj.schema.queryLanguageTypeAndVersion">${xqj.schema.queryLanguageTypeAndVersion}</prop>
				<prop key="xqj.schema.holdability">${xqj.schema.holdability}</prop>
				<prop key="xqj.schema.scrollability">${xqj.schema.scrollability}</prop>
				<prop key="xqj.schema.queryTimeout">${xqj.schema.queryTimeout}</prop>
				<!--prop key="xqj.schema.defaultNamespaces">${xqj.schema.defaultNamespaces}</prop-->
			</props>
		</property>
    </bean>

	<bean id="popManager" class="com.bagri.xdm.cache.hazelcast.management.PopulationManager">
		<constructor-arg ref="hzInstance" />
		<property name="schemaName" value="${xdm.schema.name}"/>
		<property name="populationSize" value="${xdm.schema.population.size}"/>
	</bean>

</beans>
